# This tests how `fold` behaves when missing various arguments, along with
# commentary on why each case behaves the way it does:
{ "Example 0":
    # The inferred type will be:
    #
    #     Bool -> Optional Natural
    #
    # … because this will elaborate to:
    #
    #     fold{ false: some 0, true: null }
    fold{ false: 0 }

, "Example 1":
    # The inferred type will be:
    #
    #     forall (a : Type) . Natural -> Optional a`
    #
    # … because this will elaborate to:
    #
    #     fold{ succ x: x, zero: null }
    #
    # … and the inferred type correctly deduces that must always return `null`
    # no matter what `Natural` number we provide.
    fold{ succ x: x }

, "Example 2":
    # The inferred type will be:
    #
    #     forall (a : Type) . Optional (Optional a) -> Optional a
    #
    # … because this will elaborate to:
    #
    #     fold{ some x: x, null: null }
    fold{ some x: x }

, "Example 3":
    # The inferred type will be:
    #
    #     Optional Natural -> Optional Natural
    #
    # … because this will elaborate to:
    #
    #     fold{ some x: some (x + 1), null: null }
    #
    # Note that (unlike the previous example) the typechecker has to insert a
    # `some` around the `some` handler, which is why the inferred type has a
    # different shape than the previous example.
    fold{ some x: x + 1 }

, "Example 4":
    # The inferred type will be:
    #
    #     forall (a : Type) (b : Type) . List a -> Optional b
    #
    # … because this will elaborate to:
    #
    #     fold{ cons: \x y -> y, nil: null }
    fold{ cons: \x y -> y }
}
